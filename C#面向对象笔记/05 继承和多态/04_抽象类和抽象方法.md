## 本节目标

1. abstract关键字：声明抽象类和抽象方法

## abstract：声明抽象类或抽象方法


C# abstract 关键字代表的是抽象的，使用该关键字能修饰类和方法，修饰的方法被称为抽象方法、修饰的类被称为抽象类。

在 C# 语言中**抽象方法是一种不带方法体的方法，仅包含方法的定义**，语法形式如下。

```C#
	[访问修饰符]  abstract  方法返回值类型  方法名(参数列表);
```

**抽象方法无方法体，定义后面的“;”符号是必须保留的。**

**抽象方法必须定义在抽象类中。**

在定义抽象类时，若使用 abstract 修饰类，将其放到 class 关键字的前面，语法形式如下。

```C#
	[访问修饰符]  abstract class  类名
	{
		//类成员
	}
```

其中“abstract”关键字也可以放到访问修饰符的前面。

在抽象类中可以定义抽象方法，也可以定义非抽象方法。

通常抽象类会被其他类继承，并重写其中的抽象方法或者虚方法。

此外，尽管在抽象类中仍然能定义构造器，但**抽象类不能实例化**，即不能使用如下语句。
new  抽象类的名称();

【实例 1】创建抽象类 ExamResult，并在类中定义数学 (Math)、英语 (English) 成绩的属性，定义抽象方法计算总成绩。

分别定义数学专业和英语专业的学生类继承抽象类 ExamResult，重写计算总成绩的方法并根据科目分数的不同权重计算总成绩。

其中，数学专业的数学分数占60%、英语分数占40%；英语专业的数学分数占40%、英语分数占60%。

根据题目要求，代码如下。

```C#
	abstract class ExamResult
	{
		//学号
		public int Id { get; set; }
		//数学成绩
		public double Math { get; set; }
		//英语成绩
		public double English { get; set; }
		//计算总成绩
		public abstract void Total();
	}
	class MathMajor : ExamResult
	{
		public override void Total()
		{
			double total = Math * 0.6 + English * 0.4;
			Console.WriteLine("学号为" + Id + "数学专业学生的成绩为：" + total);
		}
	}
	class EnglishMajor : ExamResult
	{
		public override void Total()
		{
			double total = Math * 0.4 + English * 0.6;
			Console.WriteLine("学号为" + Id + "英语专业学生的成绩为：" + total);
		}
	}
```

在 Main 方法中分别创建 MathMajor 和 EnglishMajor 类的对象，并调用其中的 Total 方法，代码如下。

```C#
	class Program
	{
		static void Main(string[] args)
		{
			MathMajor mathMajor = new MathMajor();
			mathMajor.Id = 1;
			mathMajor.English = 80;
			mathMajor.Math = 90;
			mathMajor.Total();
			EnglishMajor englishMajor = new EnglishMajor();
			englishMajor.Id = 2;
			englishMajor.English = 80;
			englishMajor.Math = 90;
			englishMajor.Total();
		}
	}
```

在实际应用中，子类仅能重写父类中的虚方法或者抽象方法，当不需要使用父类中方法的内容时，将其定义成抽象方法，否则将方法定义成虚方法。



## 多态浅析


在 C# 语言中多态称为运行时多态，也就是在程序运行时自动让父类的实例调用子类中重写的 方法，它并不是在程序编译阶段完成的。

使用继承实现多态，实际上是指子类在继承父类后，重写了父类的虚方法或抽象方法。

在创建父类的对象指向每一个子类的时候，根据调用的不同子类中重写的方法产生了不同的执行效果。

总而言之，使用继承实现多态必须满足以下两个条件。

 	1. **子类在继承父类时必须有重写的父类的方法。**
 	2. **在调用重写的方法时，必须创建父类的对象指向子类(即子类转换成父类)。**

【实例】根据不同层次（本科生、研究生）的学生打印出不同的专业要求。

根据题目要求，创建专业信息的抽象类 (Major)，并在其中定义学号 (Id)、姓名 (Name)，以及打印专业要求的抽象方法 (Requirenwnt)。

分别使用本科生和研究生类继承专业信息类，并重写其中的打印专业要求的方法。实现的代码如下。

```C#
	class Program
	{
		static void Main(string[] args)
		{
			Major major1 = new Undergraduate();
			major1.Id = 1;
			major1.Name = "张晓";
			Console.WriteLine("本科生信息：");
			Console.WriteLine("学号：" + major1.Id + "姓名：" + major1.Name);
			major1.Requirement();
			Major major2 = new Graduate();
			major2.Id = 2;
			major2.Name = "李明";
			Console.WriteLine("研究生信息：");
			Console.WriteLine("学号：" + major2.Id + "姓名：" + major2.Name);
			major2.Requirement();
		}
	}

	abstract class Major
	{
		public int Id { get; set; }
		public string Name { get; set; }
		public abstract void Requirement();
	}
	class Undergraduate :Major
	{
		public override void Requirement()
		{
			Console.WriteLine("本科生学制4年，必须修满48学分");
		}
	}
	class Graduate : Major
	{
		public override void Requirement()
		{
			Console.WriteLine("研究生学制3年，必须修满32学分");
		}
	}
```

执行上面的代码，查看效果。

从上面的执行效果可以看出，创建父类的实例指向了不同的子类，在程序运行时会自动调用子类中重写后的方法内容，显示出本科生和研究生的要求信息。

## 小结

1. 用abstract关键字定义抽象方法和抽象类；
2. 抽象方法必须在抽象类中，抽象类中不一定要有抽象方法；
3. 抽象类不被实例化，因为抽象方法没有具体实现代码，调用无意义；
4. 抽象方法的目的在于指定子类必须实现与这一方法关联的行为，如果不实现会报错，从而实现规范。
5. 如果父类被声明为抽象类，并存在未实现的抽象方法，那么子类就必须实现父类中所有的abstract成员，除非该类也是抽象的。